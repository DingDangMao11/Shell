https://images2015.cnblogs.com/blog/1122838/201703/1122838-20170322222435455-605613985.png

```
正则表达式有两种规范，分别是Basic（基础）规范和Extended（扩展）规范。
grep默认按照Basic规范来写，如果加“-E”选项的话就表示Extended规范。
     Basic规范中字符?+{}|()解释为普通字符，要表示特殊含义的话需要加\转义。
     Extended扩展规范中，字符?+{}|()就表示特殊含义。
```
```
元字符 	      功能 	                             元字符 	             功能
 ^ 	           匹配字符串的开始位置          	       $ 	           匹配字符串的结束位置
 . 	           匹配任意单个字符 	                   * 	           匹配子表达式0次或n次
 + 	           匹配子表达式一次或n次 	              {n}          	匹配n次
 {n，} 	        至少匹配n次 	                     {n,m} 	       匹配n-m次
 ？ 	          匹配子表达式一次或0次 	             （） 	        将括号里面的表达式定义为组
 [xyz] 	       匹配xyz任意一个字符         	       [a-Z] 	       匹配指定字符范围的任意一个
 [^a-Z] 	       匹配不在范围的任意字符 	             | 	                或
 
 \< 单词头 单词一般以空格或特殊字符做分隔,连续的字符串被当做单词

 \> 单词尾
 
 ^[^] 非字符组内的字符开头的行
 
 ^ 以什么开头（同一行）
 
 $ 以什么结尾（同一行）

 . 除了换行符以外的任意单个字符

 * 紧挨的左边的第一个字符出现零个到无穷个

 + 紧挨的左边的第一个字符出现1个到无穷个

 ? 紧挨的左边的第一个字符出现0次到1次

 .* 所有字符
 ```
grep种类：grep      fgrep      pgrep     egrep  

                      -n  :显示行号

                      -o  :只显示匹配的内容

                      -q  :静默模式，没有任何输出，得用$?来判断执行成功没有，即有没有过滤到想要的内容

                      -l  ：如果匹配成功，则只将文件名打印出来，失败则不打印，通常-rl一起用，grep -rl 'root' /etc 

                      -A  :如果匹配成功，则将匹配行及其后n行一起打印出来

                      -B  :如果匹配成功，则将匹配行及其前n行一起打印出来

                      -C  :如果匹配成功，则将匹配行及其前后n行一起打印出来

                      --color

                      -c  :如果匹配成功，则将匹配到的行数打印出来

                      -E  :等于egrep，扩展

                      -i  ：忽略大小写 

                      -v  :取反，不匹配

                      -w：匹配单词

                      -rl ：递归寻找并显示文件名

 

sed：流编辑器 stream editer,是以行为单位的处理程序
         a 后插

         c 替换

         i 前插

         d 删除

         p 打印匹配的行 一般和 -n 参数连用,以屏蔽默认输出

        r 从文件中读入

         w 写入到文件中作业二：grep作业（正则表达式及字符处理）

         ! 命令取反 

        {} 命令组合 命令用分号分隔 {1h;G} 可以理解为 -e 参数的另一种写法

         = 打印行号(输入行的号码,而非处理的次数行号) 

         n 读入下一行到模式空间 

         N 而是追加下一行到模式空间，再把当前行和下一行同时应用后面的命令

         s 字符串替换

 

awk

      -F 可以定义指定分隔符：(冒号）

      -v 定义变量并赋值 也可以借用次方式从shell变量中引入

      NF表示当前以分隔符（：）为分隔单位的行有几段内容

      NR 表示行号

      FNR表示读入行所在文件中的行数

        -v 定义变量并赋值


              == 判断；>=大于等于；<=小于等于；!=  非；>大于；<小于； ~ 使用正则定位 ; !~正则取反

         &&且

         ||或

      |sort  |uniq        配续去重（排列顺序再去除重读的）

      du -sh     统计文件大小    

       find / -size +30M 找出大于30M的文件
       
       find / -size +10M -size -30M 找出大于10M小于30M的文件
       
       
       
       
```       
  grep作业（正则表达式及字符处理）

目标文件/etc/passwd,使用grep命令或egrep
1．显示出所有含有root的行：

grep 'root' /etc/passwd 

 

2．输出任何包含bash的所有行，还要输出紧接着这行的上下各两行的内容：

grep `bash` -C 2 /etc/passwd 


3. 显示出有多少行含有nologin。

grep -c 'nologin' /etc/passwd


4．显示出那些行含有root，并将行号一块输出。

grep -n 'nologin' /etc/passwd


5．显示出文件中

grep -l 'root' /etc/passwd


6．新建用户
abominable
abominate
anomie
atomize
编写正则表达式，将他们匹配出来

egrep 'a.omi(nabl|nat|z|)e' /etc/passwd


7．建四个用户
Alex213sb
Wpq2222b
yH438PIG
egon666
egon

过滤出用户名组成是字母+数字+字母的行

egrep '^[a-Z]+[0-9]+[a-Z]+' /etc/passwd


8．显示出/etc目录下所有包含root的文件名

grep -w 'root' /etc


9. 过滤掉/etc/ssh/sshd_config内所有注释和所有空行

grep -v '^#' /etc/ssh/sshd_config |grep -v '^ *$'


作业二：Sed作业：以/etc/passwd文件为模板

1，删除文件每行的第一个字符。

 sed -r 's/^(.)(.*)/\2/' /etc/passwd

2，删除文件每行的第二个字符。

 sed -r 's/^(.)(.)(.*)/\1\3/' /etc/passwd

3，删除文件每行的最后一个字符。

 sed -r 's/(.*)(.)$/\1/' /etc/passwd

4，删除文件每行的倒数第二个字符。

 sed -r 's/(.*)(.)(.)$/\1\3/' /etc/passwd

5，删除文件每行的第二个单词。

 sed -r 's/^([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]+)/\1\2\4/' /etc/passwd

6，删除文件每行的倒数第二个单词。

 sed -r 's/([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)$/\1\3\4/' /etc/passwd

7，删除文件每行的最后一个单词。

 sed -r 's/([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)$/\1\2\3/' /etc/passwd

8，交换每行的第一个字符和第二个字符。

 sed -r 's/^(.)(.*)(.)$/\3\2\1/' /etc/passwd

9，交换每行的第一个字符和第二个单词。

 sed -r 's/^(.)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]+)/\4\2\3\1\5/' /etc/passwd

10，交换每行的第一个单词和最后一个单词。

  sed -r 's/^([a-Z]+)([^a-Z]+)(.*)([^a-Z]+)([a-Z]+)$/\5\2\3\4\1/' /etc/passwd

11，删除一个文件中所有的数字。

  sed -r 's/[0-9]//g' /etc/passwd

12，删除每行开头的所有空格。

  sed -r 's/^ *//g' /etc/passwd

13，用制表符替换文件中出现的所有空格。

  sed -r 's/ /\t/g' /etc/passwd

14，把所有大写字母用括号（）括起来。

  sed -r 's/[A-Z]/(&)/g' /etc/passwd

15，打印每行3次。

  sed 'p;p' /etc/passwd

16，只显示每行的第一个单词。

  sed -r 's/^([a-Z]+)([^a-Z]+)(.*)/\1/' /etc/passwd

17，打印每行的第一个单词和第三个单词。

  sed -r 's/^([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]+)([a-Z]+)([^a-Z]+)/\5\2\3\4\1\6/' /etc/passwd

18，用命令获取格式为 mm/yy/dd 的日期格式，结合管道，将其换成 mm；yy；dd格式

      date | sed -r ' s/ /; /g'

作业三：awk文本处理

1)打印uid在0~40范围内的用户名

awk -F: '$3>0 && $3<40{print $1,$3}' passwd

2)打印第5-10行的行号和用户名

awk -F: 'NR>=5 && NR<=10{print NR $1}' passwd

3)打印奇数行

awk '(NR%2){print $0}' passwd 

4)打印偶数行

awk '!(NR%2){print $0}' passwd 

5)打印字段数大于5的行

awk -F: '(NF>3){print $0}' passwd

6)打印UID不等于GID的用户名

awk -F: '($3 != $4){print $0}' passwd 

7)打印没有指定shell的用户

awk -F: '($NF != "/bin/bash"){print $0}' passwd

```
